substitutions:   # esp32c3-1.yaml
  device_name: xiao-2 #"esp32c3-1"
  friendly_name: XIAO 2 (136) #ESP32C3-1 (136)
  api_key: "CaS8Zmzvcgd1PdfXbbqjj0eykt6DZ2aeU8RVClLteOY=" #"fmlpfRzTy+RXkwsNjjdKiGJDPWFKRWsqwDxk4fyAEBI="  # Commented out: Disables API encryption for testing per your request.
  ota_password: "79adc277830a91a740960331973a1c14" #"dba6cbb118b753240121b7d266f9ff56"  # Keep uncommented: Secure OTA password as previously agreed.
  ap_password: "JmdPHW7qAr8S"
  wifi_ssid: !secret wifi_ssid
  wifi_password: !secret wifi_password
  #run_min_initial: '240'  # Initial run min (seconds)
  #sleep_dur_initial: '120'  # Initial sleep duration (seconds)
  #countdown_dur: '30'  # Countdown length (seconds)

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  #platformio_options: #old
   # board_build.flash_mode: dio #old
  on_boot:
    priority: -100
    then:
      - lambda: |-
          ESP_LOGI("boot", "[BOOT] Device booting...");
          const char *reason_str;
          esp_reset_reason_t reason = esp_reset_reason();
          switch (reason) {
            case ESP_RST_UNKNOWN:     reason_str = "Unknown"; break;
            case ESP_RST_POWERON:     reason_str = "Power On"; break;
            case ESP_RST_EXT:         reason_str = "External Reset"; break;
            case ESP_RST_SW:          reason_str = "Software Reset"; break;
            case ESP_RST_PANIC:       reason_str = "Panic"; break;
            case ESP_RST_INT_WDT:     reason_str = "Interrupt WDT"; break;
            case ESP_RST_TASK_WDT:    reason_str = "Task WDT"; break;
            case ESP_RST_WDT:         reason_str = "Other WDT"; break;
            case ESP_RST_DEEPSLEEP:   reason_str = "Deep Sleep Wake"; break;
            case ESP_RST_BROWNOUT:    reason_str = "Brownout"; break;
            case ESP_RST_SDIO:        reason_str = "SDIO"; break;
            case ESP_RST_USB:         reason_str = "USB"; break;
            case ESP_RST_JTAG:        reason_str = "JTAG"; break;
            case ESP_RST_EFUSE:       reason_str = "Efuse"; break;
            case ESP_RST_PWR_GLITCH:  reason_str = "Power Glitch"; break;
            case ESP_RST_CPU_LOCKUP:  reason_str = "CPU Lockup"; break;
            default:                  reason_str = "Unknown"; break;
          }
          ESP_LOGI("reset", "[BOOT] Reset reason: %d (%s)", reason, reason_str);
          id(esp_reset_reason_text).publish_state(reason_str);
          ESP_LOGI("boot", "[BOOT] Initial uptime: %.1fs", id(esp_uptime).state);
      - lambda: |-
          id(sleep_allowed) = !id(deep_sleep_override).state;  // Set based on local switch (off = allow)
          ESP_LOGI("sleep", "[BOOT] Deep sleep %s at boot (based on local override).",
                  id(sleep_allowed) ? "ALLOWED" : "PREVENTED");
      - lambda: |-
          std::string opt = id(logger_level_select).current_option();
          int level = ESPHOME_LOG_LEVEL_VERBOSE;  // Default
          if (opt == "NONE") level = ESPHOME_LOG_LEVEL_NONE;
          else if (opt == "ERROR") level = ESPHOME_LOG_LEVEL_ERROR;
          else if (opt == "WARN") level = ESPHOME_LOG_LEVEL_WARN;
          else if (opt == "INFO") level = ESPHOME_LOG_LEVEL_INFO;
          else if (opt == "DEBUG") level = ESPHOME_LOG_LEVEL_DEBUG;
          else if (opt == "VERBOSE") level = ESPHOME_LOG_LEVEL_VERBOSE;
          else if (opt == "VERY_VERBOSE") level = ESPHOME_LOG_LEVEL_VERY_VERBOSE;
          esphome::logger::global_logger->set_log_level(level);
          ESP_LOGI("boot", "Restored logger level: %s", opt.c_str());
      - if:
          condition:
            lambda: 'return !id(sleep_allowed);'
          then:
            - deep_sleep.prevent: deep_sleep_1

# Enable logging
logger:
  level: VERY_VERBOSE #DEBUG  # Set to highest to enable all runtime select options; lower if you want to restrict
  baud_rate: 115200  # Keep for debugging; set to 0 once stable to disable serial logs
  # hardware_uart: UART0 #new

# Enable Home Assistant API
api:
  encryption:
    key: ${api_key} #"CaS8Zmzvcgd1PdfXbbqjj0eykt6DZ2aeU8RVClLteOY="

ota:
  - platform: esphome
    password: ${ota_password} #"79adc277830a91a740960331973a1c14"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # use_address: 192.168.158.136
  power_save_mode: light
  output_power: 8.5  # Lower TX power to save battery

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Xiao Fallback Hotspot" #"Esp32C3-1 Fallback Hotspot"
    password: ${ap_password} #"JmdPHW7qAr8S"

  # Fallback to AP if WiFi connection fails
  manual_ip:  # Optional for fixed IP after setup
    static_ip: 192.168.158.136
    gateway: 192.168.158.1
    subnet: 255.255.255.0

  on_disconnect:
    - lambda: |-
        ESP_LOGW("wifi", "WiFi disconnected - falling back to AP mode for reprovisioning.");   

captive_portal:

mdns:
  disabled: false

web_server:
  port: 80
  include_internal: true        

# Modular Packages
packages:
  max17048: !include iaq-project/packages/max17048.yaml #max17048 Fuel Guage
  aht20: !include iaq-project/packages/aht20.yaml #temp/hum sensor
  pmsx003: !include  iaq-project/packages/PMSX003.yaml #PMSX003, 7003
  board: !include iaq-project/boards/Board-Seeed-Xiao-ESP32-C3.yaml #Board specific GPIO, etc.
  base: !include iaq-project/common/base.yaml  # Hardware, logger, wifi, api, ota, etc.
  sensors: !include iaq-project/common/sensors.yaml  # All sensors and text_sensors
  sleep: !include iaq-project/common/sleep.yaml  # Deep sleep, globals, intervals
  diagnostics: !include iaq-project/common/diagnostics.yaml # resets, reasons