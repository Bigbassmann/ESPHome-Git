# ============================================================
# Profiles for ESP32C3-3
#
# Debug Mode üõ†Ô∏è
#   logger_level: DEBUG
#   wifi_psm: none
#   wifi_power: "18.0"
#   run_time: "90"
#   sleep_time: "300"
#   heartbeat: "300"
#
# Balanced Mode ‚öñÔ∏è
#   logger_level: WARN
#   wifi_psm: light
#   wifi_power: "8.5"
#   run_time: "30"
#   sleep_time: "600"
#   heartbeat: "600"
#
# Battery Saver Mode üîã
#   logger_level: ERROR
#   wifi_psm: high
#   wifi_power: "6.0"
#   run_time: "15"
#   sleep_time: "3600"
#   heartbeat: "1800"
# ============================================================


substitutions:
  mode: debug
  logger_level: DEBUG
  wifi_psm: none
  wifi_power: "18"
  run_time: "10"
  sleep_time: "90"
  heartbeat: "1"

esphome:
  name: esp32c3-3
  friendly_name: ESP32C3-3
  on_boot:
    priority: -100
    then:
    # Core state
      - text_sensor.template.publish:
          id: sleep_state
          state: "Awake"

      # Last awake timestamp
      - text_sensor.template.publish:
          id: last_awake_timestamp
          state: !lambda |-
            auto t = id(ha_time).now();
            char str[32];
            sprintf(str, "%04d-%02d-%02d %02d:%02d:%02d",
                    t.year, t.month, t.day_of_month,
                    t.hour, t.minute, t.second);
            ESP_LOGI("on_boot", "Device woke at %s", str);  // log to ESPHome console
            return std::string(str);

      # Profile diagnostics
      - text_sensor.template.publish:
          id: profile_mode_text
          state: "${mode}"
      - text_sensor.template.publish:
          id: profile_logger_level
          state: "${logger_level}"
      - text_sensor.template.publish:
          id: profile_wifi_psm
          state: "${wifi_psm}"
      - text_sensor.template.publish:
          id: profile_wifi_power
          state: "${wifi_power} dBm"

      # Numeric profile values
      - sensor.template.publish:
          id: profile_run_time
          state: !lambda 'return (float)${run_time};'
      - sensor.template.publish:
          id: profile_sleep_time
          state: !lambda 'return (float)${sleep_time};'
      - sensor.template.publish:
          id: profile_heartbeat
          state: !lambda 'return (float)${heartbeat};'

      # Adaptive diagnostics baseline
      - text_sensor.template.publish:
          id: adaptive_sleep_mode
          state: "Normal Mode"
      - sensor.template.publish:
          id: adaptive_sleep_duration
          state: !lambda 'return id(sleep_duration).state;'
      - text_sensor.template.publish:
          id: active_wakeup_sources
          state: !lambda |-
            if (id(use_gpio_wakeup).state) {
              return "Timer + GPIO4";
            } else {
              return "Timer";
            }

      # Wakeup cause evaluation
      - text_sensor.template.publish:
          id: wakeup_cause
          state: !lambda |-
            switch (esp_sleep_get_wakeup_cause()) {
              case ESP_SLEEP_WAKEUP_TIMER: return "Timer";
              case ESP_SLEEP_WAKEUP_GPIO:  return "GPIO";
              case ESP_SLEEP_WAKEUP_UNDEFINED: return "Undefined";
              default: return "Other";
            }

time:
  - platform: sntp # homeassistant
    id: ha_time

esp32:
  board: seeed_xiao_esp32c3
  variant: esp32c3
  framework:
    type: arduino

logger:
  level: ${logger_level}

api:
  encryption:
    key: "E/u080bcDoCZdoszgaRA5Eo0uH4e/h2lHfJ42GbKSqY="

ota:
  - platform: esphome
    password: "1e61d731b9e74b2ea85e2558a2193ef3"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  use_address: 192.168.158.180
  power_save_mode: ${wifi_psm}
  output_power: ${wifi_power}
  ap:
    ssid: "Esp32C3-3 Fallback Hotspot"
    password: "JlFxcEzgPgtO"

captive_portal:




i2c:
  sda: GPIO6
  scl: GPIO7
  scan: true
  id: bus_a
  frequency: 200kHz

# -------------------------------
# Numbers
# -------------------------------
number:
  - platform: template
    name: "Run Duration"
    id: run_duration
    min_value: 10
    max_value: 7200
    step: 10
    unit_of_measurement: "s"
    optimistic: true
    initial_value: ${run_time}
    on_value:
      then:
        - logger.log:
            format: "Run Duration changed ‚Üí %.0f s"
            args: [ 'x' ]

  - platform: template
    name: "Sleep Duration"
    id: sleep_duration
    min_value: 10
    max_value: 14400
    step: 10
    unit_of_measurement: "s"
    optimistic: true
    initial_value: ${sleep_time}
    on_value:
      then:
        - logger.log:
            format: "Sleep Duration changed ‚Üí %.0f s"
            args: [ 'x' ]

# -------------------------------
# Sensors
# -------------------------------
sensor:
  - platform: aht10
    variant: AHT20
    temperature:
      name: "MBR Temperature"
      id: lr_temp_c
      unit_of_measurement: "¬∞F"
      accuracy_decimals: 1
      filters:
        - delta: 0.0001
        - heartbeat: ${heartbeat}s
        - lambda: return x * (9.0/5.0) + 32.0;
    humidity:
      name: "MBR Humidity"
      filters:
        - delta: 0.0001
        - heartbeat: ${heartbeat}s

  - platform: uptime
    name: "ESP Uptime"

  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  - platform: adc
    pin: GPIO2
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: 60s
    filters:
      - multiply: 2.0

  - platform: template
    name: "Adaptive Sleep Duration"
    id: adaptive_sleep_duration
    unit_of_measurement: "s"
    accuracy_decimals: 0
    update_interval: never
    lambda: |-
      return id(adaptive_sleep_duration).state;

# -------------------------------
# Switch State Sensors (0 = OFF, 1 = ON)
# -------------------------------

  - platform: template
    name: "Prevent Deep Sleep State"
    id: prevent_state_sensor
    unit_of_measurement: "bool"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: 'return id(deep_sleep_prevent).state ? 1 : 0;'

  - platform: template
    name: "Use GPIO Wakeup State"
    id: gpio_state_sensor
    unit_of_measurement: "bool"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: 'return id(use_gpio_wakeup).state ? 1 : 0;'

  - platform: template
    name: "Force Deep Sleep State"
    id: force_state_sensor
    unit_of_measurement: "bool"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: 'return id(force_deep_sleep).state ? 1 : 0;'

  - platform: template
    name: "Adaptive Sleep Enable State"
    id: adaptive_state_sensor
    unit_of_measurement: "bool"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: 'return id(adaptive_sleep_enable).state ? 1 : 0;'

  # Substitution diagnostics
  - platform: template
    name: "Profile Run Time"
    id: profile_run_time
    unit_of_measurement: "s"
    accuracy_decimals: 0
    update_interval: never
    lambda: |-
      return (float) ${run_time};

  - platform: template
    name: "Profile Sleep Time"
    id: profile_sleep_time
    unit_of_measurement: "s"
    accuracy_decimals: 0
    update_interval: never
    lambda: |-
      return (float) ${sleep_time};

  - platform: template
    name: "Profile Heartbeat"
    id: profile_heartbeat
    unit_of_measurement: "s"
    accuracy_decimals: 0
    update_interval: never
    lambda: |-
      return (float) ${heartbeat};
  

text_sensor:
  - platform: template
    name: "Wakeup Cause"
    id: wakeup_cause
    update_interval: never
    lambda: |-
      return id(wakeup_cause).state;

  - platform: template
    name: "Adaptive Sleep Mode"
    id: adaptive_sleep_mode
    update_interval: never
    lambda: |-
      return id(adaptive_sleep_mode).state;

  - platform: template
    name: "Sleep State"
    id: sleep_state
    update_interval: never
    lambda: |-
      return id(sleep_state).state;


  # -------------------------------
# Diagnostic Text Sensor
# ------------------------------
  - platform: template
    name: "Active Wakeup Sources"
    id: active_wakeup_sources
    update_interval: never
    lambda: |-
      return id(active_wakeup_sources).state;

  - platform: template
    name: "Profile Mode"
    id: profile_mode_text
    update_interval: never
    lambda: |-
      return std::string("${mode}");

  - platform: template
    name: "Profile Logger Level"
    id: profile_logger_level
    update_interval: never
    lambda: |-
      return std::string("${logger_level}");

  - platform: template
    name: "Profile WiFi Power Save"
    id: profile_wifi_psm
    update_interval: never
    lambda: |-
      return std::string("${wifi_psm}");

  - platform: template
    name: "Profile WiFi Output Power"
    id: profile_wifi_power
    update_interval: never
    lambda: |-
      return std::string("${wifi_power} dBm");

  - platform: template
    name: "Last Awake Timestamp"
    id: last_awake_timestamp
    update_interval: never    

# -------------------------------
# Switches
# -------------------------------
switch:
  - platform: template
    name: "Use GPIO Wakeup"
    id: use_gpio_wakeup
    optimistic: true
    restore_mode: ALWAYS_OFF
    turn_on_action:
      - logger.log: "Use GPIO Wakeup ‚Üí ON"
    turn_off_action:
      - logger.log: "Use GPIO Wakeup ‚Üí OFF"

  - platform: template
    name: "Prevent Deep Sleep"
    id: deep_sleep_prevent
    optimistic: true
    restore_mode: ALWAYS_ON
    turn_on_action:
      - logger.log: "Prevent Deep Sleep ‚Üí ON"
    turn_off_action:
      - logger.log: "Prevent Deep Sleep ‚Üí OFF"

  - platform: template
    name: "Force Deep Sleep"
    id: force_deep_sleep
    optimistic: true
    restore_mode: ALWAYS_OFF
    turn_on_action:
      - logger.log: "Force Deep Sleep ‚Üí ON"
      - deep_sleep.enter:
          id: deep_sleep_ctrl
          sleep_duration: !lambda 'return (int)id(sleep_duration).state;'
    turn_off_action:
      - logger.log: "Force Deep Sleep ‚Üí OFF"

  - platform: template
    name: "Adaptive Sleep Enable"
    id: adaptive_sleep_enable
    optimistic: true
    restore_mode: ALWAYS_OFF
    turn_on_action:
      - logger.log: "Adaptive Sleep Enable ‚Üí ON"
    turn_off_action:
      - logger.log: "Adaptive Sleep Enable ‚Üí OFF"

  - platform: template
    name: "Force Sleep Override"
    id: force_sleep_override
    optimistic: true
    restore_mode: ALWAYS_OFF
    turn_on_action:
      - logger.log: "Force Sleep Override ‚Üí ON"
    turn_off_action:
      - logger.log: "Force Sleep Override ‚Üí OFF"    


# -------------------------------
# Deep Sleep
# -------------------------------
deep_sleep:
  id: deep_sleep_ctrl
  run_duration: ${run_time}s
  sleep_duration: ${sleep_time}s
  wakeup_pin:
    number: GPIO4
    inverted: true
    mode: INPUT_PULLUP
  wakeup_pin_mode: KEEP_AWAKE

# -------------------------------
# Script
# -------------------------------
script:
  - id: dynamic_sleep_cycle
    mode: restart
    then:
      - if:
          condition:
            switch.is_on: force_sleep_override
          then:
            - logger.log: "Force Sleep Override active ‚Üí ignoring API connection and proceeding to deep sleep"
      - logger.log: "Starting dynamic run cycle..."
      - delay: !lambda 'return (int)id(run_duration).state * 1000;'
      - logger.log: "Run duration complete. Preparing for sleep..."
      - text_sensor.template.publish:
          id: sleep_state
          state: "Sleeping"
      - lambda: |-
          int base_sleep = (int)id(sleep_duration).state;
          int sleep_time = base_sleep;
          std::string mode_str = "Normal Mode";

          if (id(adaptive_sleep_enable).state) {
            float v = id(battery_voltage).state;
            if (v < 3.3f) {
              sleep_time = base_sleep * 2;
              mode_str = "Low Battery Mode";
            } else if (v > 3.8f) {
              sleep_time = base_sleep / 2;
              mode_str = "High Battery Mode";
            }
          } else {
            mode_str = "Adaptive Disabled (Base Sleep)";
          }

          // Publish updated diagnostics
          id(adaptive_sleep_mode).publish_state(mode_str);
          id(adaptive_sleep_duration).publish_state((float)sleep_time);
          id(deep_sleep_ctrl).set_sleep_duration(sleep_time);

          std::string sources = "Timer";
          if (id(use_gpio_wakeup).state) {
            sources += " + GPIO4";
          }
          id(active_wakeup_sources).publish_state(sources);

      - logger.log:
          format: "Entering deep sleep for %d s (%s). Wakeup sources: %s"
          args: [ 'int(id(adaptive_sleep_duration).state)', 'id(adaptive_sleep_mode).state.c_str()', 'id(active_wakeup_sources).state.c_str()' ]
      - deep_sleep.enter:
          id: deep_sleep_ctrl


# -------------------------------
# Interval Automation
# -------------------------------
interval:
  - interval: 10s
    then:
      
      - if:
          condition:
            switch.is_on: force_sleep_override
          then:
            - logger.log: "Force Sleep Override active ‚Üí entering deep sleep despite API connection"
            - script.execute: dynamic_sleep_cycle
          else:
            - logger.log: "Skipping deep sleep while OTA/API is active"
            - if:
                condition:
                  switch.is_off: deep_sleep_prevent
                then:
                  - if:
                      condition:
                        switch.is_on: use_gpio_wakeup
                      then:
                        - logger.log: "GPIO wakeup mode ‚Üí entering deep sleep immediately"
                        - text_sensor.template.publish:
                            id: active_wakeup_sources
                            state: "GPIO4"
                        - deep_sleep.enter:
                            id: deep_sleep_ctrl
                            # sleep_duration: 0s
                      else:
                        - script.execute: dynamic_sleep_cycle
